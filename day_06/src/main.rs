use std::{collections::{HashMap, HashSet}, borrow::Cow};
use gif::{Frame, Encoder};

type Result<T> = std::result::Result<T, Box<dyn std::error::Error>>;

const THRESHOLD: u32 = 10000;

fn main() -> Result<()> {
    let args = std::env::args().collect::<Vec<String>>();
    if args.len() != 2 {
        eprintln!("usage: {} <input-file>", args[0]);
        std::process::exit(1);
    }

    let data = std::fs::read_to_string(&args[1])?;
    let mut coordinates: Vec<Pixel> = Vec::new();
    for line in data.lines() {
        let location: Vec<i32> = line
            .split(',')
            .map(|a| a.trim().parse::<i32>().unwrap())
            .collect();
        coordinates.push(Pixel::new(location));
    }

    let (mut top, mut bottom, mut left, mut right) = (i32::MAX, i32::MIN, i32::MAX, i32::MIN);

    for pixel in &coordinates {
        if pixel.0 < left {
            left = pixel.0
        }
        if pixel.0 > right {
            right = pixel.0
        }
        if pixel.1 < top {
            top = pixel.1;
        }
        if pixel.1 > bottom {
            bottom = pixel.1
        }
    }

    part1(&coordinates, (top, bottom, left, right))?;
    image1(&coordinates, (top, bottom, left, right))?;

    part2(&coordinates, (top, bottom, left, right))?;
    image2(&coordinates, (top, bottom, left, right))?;

    Ok(())
}

fn part1(coordinates: &Vec<Pixel>, edges: (i32, i32, i32, i32)) -> Result<()> {
    let (top, bottom, left, right) = edges;
    let mut rejected_pixels: HashSet<Pixel> = HashSet::new();
    for x in (left - 1)..=(right + 1) {
        match closest((x, top - 1), &coordinates) {
            Some(&pixel) => {
                rejected_pixels.insert(pixel);
            }
            None => (),
        };

        match closest((x, bottom + 1), &coordinates) {
            Some(&pixel) => {
                rejected_pixels.insert(pixel);
            }
            None => (),
        };
    }

    for y in (top - 1)..=(bottom + 1) {
        match closest((left - 1, y), &coordinates) {
            Some(&pixel) => {
                rejected_pixels.insert(pixel);
            }
            None => (),
        };

        match closest((right + 1, y), &coordinates) {
            Some(&pixel) => {
                rejected_pixels.insert(pixel);
            }
            None => (),
        };
    }

    let mut nearest_count: HashMap<&Pixel, i32> = HashMap::new();

    for x in left..=right {
        for y in top..=bottom {
            match closest((x, y), &coordinates) {
                Some(pixel_ref) => {
                    *nearest_count.entry(pixel_ref).or_insert(0) += 1;
                }
                None => (),
            };
        }
    }
    let mut influential_pixel: Option<&Pixel> = None;
    let mut max = 0;

    for (&pixel, count) in &nearest_count {
        if !rejected_pixels.contains(pixel) {
            if *count >= max {
                influential_pixel = Some(pixel);
                max = *count;
            }
        }
    }

    println!("{:?}: {}", influential_pixel.unwrap(), max);

    Ok(())
}

fn part2(coordinates: &Vec<Pixel>, edges: (i32, i32, i32, i32)) -> Result<()> {
    let (top, bottom, left, right) = edges;
    let mut in_range_count = 0;
    for x in left..=right {
        for y in top..=bottom {
            let mut distance_sum = 0;
            for pixel in coordinates {
                distance_sum += x.abs_diff(pixel.0) + y.abs_diff(pixel.1);
            }
            if distance_sum >= THRESHOLD {
                continue;
            }
            in_range_count += 1;
        }
    }

    println!("in range {}: {}", THRESHOLD, in_range_count);

    Ok(())
}

fn image1(coordinates: &Vec<Pixel>, edges: (i32, i32, i32, i32)) -> Result<()> {
    let mut image = std::fs::File::create("part1.gif")?;
    const EXTRA: u16 = 100;
    let top = edges.0 - EXTRA as i32;
    let bottom = edges.1 + EXTRA as i32;
    let left = edges.2 - EXTRA as i32;
    let right = edges.3 + EXTRA as i32;
    let (width, height) = (right.abs_diff(left) as u16 + 1, bottom.abs_diff(top) as u16 + 1);

    let mut pixel_color_map: HashMap<&Pixel, u8> = HashMap::new();
    for (idx, coordinate) in coordinates.iter().enumerate() {
        pixel_color_map.insert(coordinate, idx as u8);
    }

    let mut image_data: Vec<u8> = Vec::with_capacity(width as usize * height as usize);
    for y in top..=bottom {
        for x in left..=right {
            if x == edges.2 || x == edges.3 || y == edges.0 || y == edges.1 {
                image_data.push(0);
                continue;
            }
            match closest((x, y), coordinates) {
                Some(pixel) => {
                    image_data.push(*pixel_color_map.get(pixel).unwrap());
                }
                None => image_data.push(0),
            }
        }
    }
    let color256 = [0x00u8, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x80, 0x00, 0x00, 0x87, 0x00, 0x00, 0xaf, 0x00, 0x00, 0xd7, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x5f, 0x00, 0x00, 0x5f, 0x5f, 0x00, 0x5f, 0x87, 0x00, 0x5f, 0xaf, 0x00, 0x5f, 0xd7, 0x00, 0x5f, 0xff, 0x00, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x87, 0x00, 0x00, 0x87, 0x5f, 0x00, 0x87, 0x87, 0x00, 0x87, 0xaf, 0x00, 0x87, 0xd7, 0x00, 0x87, 0xff, 0x00, 0xaf, 0x00, 0x00, 0xaf, 0x5f, 0x00, 0xaf, 0x87, 0x00, 0xaf, 0xaf, 0x00, 0xaf, 0xd7, 0x00, 0xaf, 0xff, 0x00, 0xd7, 0x00, 0x00, 0xd7, 0x5f, 0x00, 0xd7, 0x87, 0x00, 0xd7, 0xaf, 0x00, 0xd7, 0xd7, 0x00, 0xd7, 0xff, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x5f, 0x00, 0xff, 0x87, 0x00, 0xff, 0xaf, 0x00, 0xff, 0xd7, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x08, 0x08, 0x08, 0x12, 0x12, 0x12, 0x1c, 0x1c, 0x1c, 0x26, 0x26, 0x26, 0x30, 0x30, 0x30, 0x3a, 0x3a, 0x3a, 0x44, 0x44, 0x44, 0x4e, 0x4e, 0x4e, 0x58, 0x58, 0x58, 0x5f, 0x00, 0x00, 0x5f, 0x00, 0x5f, 0x5f, 0x00, 0x87, 0x5f, 0x00, 0xaf, 0x5f, 0x00, 0xd7, 0x5f, 0x00, 0xff, 0x5f, 0x5f, 0x00, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x87, 0x5f, 0x5f, 0xaf, 0x5f, 0x5f, 0xd7, 0x5f, 0x5f, 0xff, 0x5f, 0x87, 0x00, 0x5f, 0x87, 0x5f, 0x5f, 0x87, 0x87, 0x5f, 0x87, 0xaf, 0x5f, 0x87, 0xd7, 0x5f, 0x87, 0xff, 0x5f, 0xaf, 0x00, 0x5f, 0xaf, 0x5f, 0x5f, 0xaf, 0x87, 0x5f, 0xaf, 0xaf, 0x5f, 0xaf, 0xd7, 0x5f, 0xaf, 0xff, 0x5f, 0xd7, 0x00, 0x5f, 0xd7, 0x5f, 0x5f, 0xd7, 0x87, 0x5f, 0xd7, 0xaf, 0x5f, 0xd7, 0xd7, 0x5f, 0xd7, 0xff, 0x5f, 0xff, 0x00, 0x5f, 0xff, 0x5f, 0x5f, 0xff, 0x87, 0x5f, 0xff, 0xaf, 0x5f, 0xff, 0xd7, 0x5f, 0xff, 0xff, 0x62, 0x62, 0x62, 0x6c, 0x6c, 0x6c, 0x76, 0x76, 0x76, 0x80, 0x00, 0x00, 0x80, 0x00, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x87, 0x00, 0x00, 0x87, 0x00, 0x5f, 0x87, 0x00, 0x87, 0x87, 0x00, 0xaf, 0x87, 0x00, 0xd7, 0x87, 0x00, 0xff, 0x87, 0x5f, 0x00, 0x87, 0x5f, 0x5f, 0x87, 0x5f, 0x87, 0x87, 0x5f, 0xaf, 0x87, 0x5f, 0xd7, 0x87, 0x5f, 0xff, 0x87, 0x87, 0x00, 0x87, 0x87, 0x5f, 0x87, 0x87, 0x87, 0x87, 0x87, 0xaf, 0x87, 0x87, 0xd7, 0x87, 0x87, 0xff, 0x87, 0xaf, 0x00, 0x87, 0xaf, 0x5f, 0x87, 0xaf, 0x87, 0x87, 0xaf, 0xaf, 0x87, 0xaf, 0xd7, 0x87, 0xaf, 0xff, 0x87, 0xd7, 0x00, 0x87, 0xd7, 0x5f, 0x87, 0xd7, 0x87, 0x87, 0xd7, 0xaf, 0x87, 0xd7, 0xd7, 0x87, 0xd7, 0xff, 0x87, 0xff, 0x00, 0x87, 0xff, 0x5f, 0x87, 0xff, 0x87, 0x87, 0xff, 0xaf, 0x87, 0xff, 0xd7, 0x87, 0xff, 0xff, 0x8a, 0x8a, 0x8a, 0x94, 0x94, 0x94, 0x9e, 0x9e, 0x9e, 0xa8, 0xa8, 0xa8, 0xaf, 0x00, 0x00, 0xaf, 0x00, 0x5f, 0xaf, 0x00, 0x87, 0xaf, 0x00, 0xaf, 0xaf, 0x00, 0xd7, 0xaf, 0x00, 0xff, 0xaf, 0x5f, 0x00, 0xaf, 0x5f, 0x5f, 0xaf, 0x5f, 0x87, 0xaf, 0x5f, 0xaf, 0xaf, 0x5f, 0xd7, 0xaf, 0x5f, 0xff, 0xaf, 0x87, 0x00, 0xaf, 0x87, 0x5f, 0xaf, 0x87, 0x87, 0xaf, 0x87, 0xaf, 0xaf, 0x87, 0xd7, 0xaf, 0x87, 0xff, 0xaf, 0xaf, 0x00, 0xaf, 0xaf, 0x5f, 0xaf, 0xaf, 0x87, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xd7, 0xaf, 0xaf, 0xff, 0xaf, 0xd7, 0x00, 0xaf, 0xd7, 0x5f, 0xaf, 0xd7, 0x87, 0xaf, 0xd7, 0xaf, 0xaf, 0xd7, 0xd7, 0xaf, 0xd7, 0xff, 0xaf, 0xff, 0x00, 0xaf, 0xff, 0x5f, 0xaf, 0xff, 0x87, 0xaf, 0xff, 0xaf, 0xaf, 0xff, 0xd7, 0xaf, 0xff, 0xff, 0xb2, 0xb2, 0xb2, 0xbc, 0xbc, 0xbc, 0xc0, 0xc0, 0xc0, 0xc6, 0xc6, 0xc6, 0xd0, 0xd0, 0xd0, 0xd7, 0x00, 0x00, 0xd7, 0x00, 0x5f, 0xd7, 0x00, 0x87, 0xd7, 0x00, 0xaf, 0xd7, 0x00, 0xd7, 0xd7, 0x00, 0xff, 0xd7, 0x5f, 0x00, 0xd7, 0x5f, 0x5f, 0xd7, 0x5f, 0x87, 0xd7, 0x5f, 0xaf, 0xd7, 0x5f, 0xd7, 0xd7, 0x5f, 0xff, 0xd7, 0x87, 0x00, 0xd7, 0x87, 0x5f, 0xd7, 0x87, 0x87, 0xd7, 0x87, 0xaf, 0xd7, 0x87, 0xd7, 0xd7, 0x87, 0xff, 0xd7, 0xaf, 0x00, 0xd7, 0xaf, 0x5f, 0xd7, 0xaf, 0x87, 0xd7, 0xaf, 0xaf, 0xd7, 0xaf, 0xd7, 0xd7, 0xaf, 0xff, 0xd7, 0xd7, 0x00, 0xd7, 0xd7, 0x5f, 0xd7, 0xd7, 0x87, 0xd7, 0xd7, 0xaf, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7, 0xff, 0xd7, 0xff, 0x00, 0xd7, 0xff, 0x5f, 0xd7, 0xff, 0x87, 0xd7, 0xff, 0xaf, 0xd7, 0xff, 0xd7, 0xd7, 0xff, 0xff, 0xda, 0xda, 0xda, 0xe4, 0xe4, 0xe4, 0xee, 0xee, 0xee, 0xff, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0x00, 0x5f, 0xff, 0x00, 0x87, 0xff, 0x00, 0xaf, 0xff, 0x00, 0xd7, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x5f, 0x00, 0xff, 0x5f, 0x5f, 0xff, 0x5f, 0x87, 0xff, 0x5f, 0xaf, 0xff, 0x5f, 0xd7, 0xff, 0x5f, 0xff, 0xff, 0x87, 0x00, 0xff, 0x87, 0x5f, 0xff, 0x87, 0x87, 0xff, 0x87, 0xaf, 0xff, 0x87, 0xd7, 0xff, 0x87, 0xff, 0xff, 0xaf, 0x00, 0xff, 0xaf, 0x5f, 0xff, 0xaf, 0x87, 0xff, 0xaf, 0xaf, 0xff, 0xaf, 0xd7, 0xff, 0xaf, 0xff, 0xff, 0xd7, 0x00, 0xff, 0xd7, 0x5f, 0xff, 0xd7, 0x87, 0xff, 0xd7, 0xaf, 0xff, 0xd7, 0xd7, 0xff, 0xd7, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x5f, 0xff, 0xff, 0x87, 0xff, 0xff, 0xaf, 0xff, 0xff, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff];
    let pixel_count = coordinates.len();
    let mut color_map: Vec<u8> = Vec::new();
    for i in (0..256usize).step_by(256 / pixel_count){
        color_map.push(color256[i]);
        color_map.push(color256[i+1]);
        color_map.push(color256[i+2]);
    }
    let mut encoder = Encoder::new(&mut image, width, height, &color_map).unwrap();
    let mut frame = Frame::default();
    frame.width = width;
    frame.height = height;
    frame.buffer = Cow::Borrowed(&image_data);
    encoder.write_frame(&frame)?;
    println!("Successfully written file part1.gif");

    Ok(())
}

fn image2(coordinates: &Vec<Pixel>, edges: (i32, i32, i32, i32)) -> Result<()> {
    let mut image = std::fs::File::create("part2.gif")?;
    const EXTRA: u16 = 100;
    let top = edges.0 - EXTRA as i32;
    let bottom = edges.1 + EXTRA as i32;
    let left = edges.2 - EXTRA as i32;
    let right = edges.3 + EXTRA as i32;
    let (width, height) = (right.abs_diff(left) as u16 + 1, bottom.abs_diff(top) as u16 + 1);

    let mut pixel_color_map: HashMap<&Pixel, u8> = HashMap::new();
    for (idx, coordinate) in coordinates.iter().enumerate() {
        pixel_color_map.insert(coordinate, idx as u8);
    }

    let mut image_data: Vec<u8> = Vec::with_capacity(width as usize * height as usize);
    let color_map = [0xff, 0xff, 0xff, 0x00, 0x00, 0x00,];
    for y in top..=bottom {
        for x in left..=right {
            let mut distance_sum = 0;
            for pixel in coordinates {
                distance_sum += x.abs_diff(pixel.0) + y.abs_diff(pixel.1);
            }
            if distance_sum >= THRESHOLD {
                image_data.push(0);
                continue;
            }
            image_data.push(1);
        }
    }
    let mut encoder = Encoder::new(&mut image, width, height, &color_map).unwrap();
    // let frame = Frame::from_palette_pixels(width, height, image_data, color_map, None);
    let mut frame = Frame::default();
    frame.width = width;
    frame.height = height;
    frame.buffer = Cow::Borrowed(&image_data);
    encoder.write_frame(&frame)?;
    println!("Successfully written file part1.gif");

    Ok(())
}

#[derive(Debug, Eq, PartialEq, Hash, Clone, Copy)]
struct Pixel(i32, i32);

impl Pixel {
    fn new(location: Vec<i32>) -> Self {
        Pixel(location[0], location[1])
    }
}

fn closest(location: (i32, i32), pixels: &Vec<Pixel>) -> Option<&Pixel> {
    let mut closest: &Pixel = &Pixel(i32::MAX, i32::MAX);
    let mut min_dist = u32::MAX;
    let mut repeat_count = 0i32;

    for pixel in pixels {
        let dist = location.0.abs_diff(pixel.0) + location.1.abs_diff(pixel.1);
        if dist < min_dist {
            min_dist = dist;
            closest = pixel;
            repeat_count = 0;
        } else if dist == min_dist {
            repeat_count += 1;
        }
    }

    if repeat_count > 0 {
        None
    } else {
        Some(closest)
    }
}
